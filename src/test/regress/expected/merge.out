--
-- MERGE
--
--\set VERBOSITY verbose
--set debug_print_rewritten = true;
--set debug_print_parse = true;
--set debug_print_pretty = true;
CREATE USER merge_privs;
CREATE USER merge_no_privs;
DROP TABLE IF EXISTS target;
NOTICE:  table "target" does not exist, skipping
DROP TABLE IF EXISTS source;
NOTICE:  table "source" does not exist, skipping
CREATE TABLE target (tid integer, balance integer);
CREATE TABLE source (sid integer, delta integer); --no index
INSERT INTO target VALUES (1, 10);
INSERT INTO target VALUES (2, 20);
INSERT INTO target VALUES (3, 30);
SELECT t.ctid is not null as matched, t.*, s.* FROM source s FULL OUTER JOIN target t ON s.sid = t.tid ORDER BY t.tid, s.sid;
 matched | tid | balance | sid | delta 
---------+-----+---------+-----+-------
 t       |   1 |      10 |     |      
 t       |   2 |      20 |     |      
 t       |   3 |      30 |     |      
(3 rows)

ALTER TABLE target OWNER TO merge_privs;
ALTER TABLE source OWNER TO merge_privs;
CREATE TABLE target2 (tid integer, balance integer);
CREATE TABLE source2 (sid integer, delta integer);
ALTER TABLE target2 OWNER TO merge_no_privs;
ALTER TABLE source2 OWNER TO merge_no_privs;
GRANT INSERT ON target TO merge_no_privs;
SET SESSION AUTHORIZATION merge_privs;
EXPLAIN (COSTS OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE
;
               QUERY PLAN               
----------------------------------------
 Merge on target t
   ->  Merge Join
         Merge Cond: (t.tid = s.sid)
         ->  Sort
               Sort Key: t.tid
               ->  Seq Scan on target t
         ->  Sort
               Sort Key: s.sid
               ->  Seq Scan on source s
(9 rows)

--
-- Errors
--
MERGE INTO target t RANDOMWORD
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
ERROR:  syntax error at or near "RANDOMWORD"
LINE 1: MERGE INTO target t RANDOMWORD
                            ^
-- MATCHED/INSERT error
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	INSERT DEFAULT VALUES
;
ERROR:  syntax error at or near "INSERT"
LINE 5:  INSERT DEFAULT VALUES
         ^
-- incorrectly specifying INTO target
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT INTO target DEFAULT VALUES
;
ERROR:  syntax error at or near "INTO"
LINE 5:  INSERT INTO target DEFAULT VALUES
                ^
-- NOT MATCHED/UPDATE
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	UPDATE SET balance = 0
;
ERROR:  syntax error at or near "UPDATE"
LINE 5:  UPDATE SET balance = 0
         ^
-- UPDATE tablename
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE target SET balance = 0
;
ERROR:  syntax error at or near "target"
LINE 5:  UPDATE target SET balance = 0
                ^
-- permissions
MERGE INTO target
USING source2
ON target.tid = source2.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
ERROR:  permission denied for relation source2
GRANT INSERT ON target TO merge_no_privs;
SET SESSION AUTHORIZATION merge_no_privs;
MERGE INTO target
USING source2
ON target.tid = source2.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
ERROR:  permission denied for relation target
GRANT UPDATE ON target2 TO merge_privs;
SET SESSION AUTHORIZATION merge_privs;
MERGE INTO target2
USING source
ON target2.tid = source.sid
WHEN MATCHED THEN
	DELETE
;
ERROR:  permission denied for relation target2
MERGE INTO target2
USING source
ON target2.tid = source.sid
WHEN NOT MATCHED THEN
	INSERT DEFAULT VALUES
;
ERROR:  permission denied for relation target2
--
-- initial tests
--
-- zero rows in source has no effect
MERGE INTO target
USING source
ON target.tid = source.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE
;
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT DEFAULT VALUES
;
ROLLBACK;
-- insert some non-matching source rows to work from
INSERT INTO source VALUES (4, 40);
SELECT * FROM source ORDER BY sid;
 sid | delta 
-----+-------
   4 |    40
(1 row)

SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
(3 rows)

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	DO NOTHING
;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE
;
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT DEFAULT VALUES
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
     |        
(4 rows)

ROLLBACK;
-- index plans
INSERT INTO target SELECT generate_series(1000,2500), 0;
ALTER TABLE target ADD PRIMARY KEY (tid);
ANALYZE target;
EXPLAIN (COSTS OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
               QUERY PLAN               
----------------------------------------
 Merge on target t
   ->  Hash Join
         Hash Cond: (s.sid = t.tid)
         ->  Seq Scan on source s
         ->  Hash
               ->  Seq Scan on target t
(6 rows)

EXPLAIN (COSTS OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE
;
               QUERY PLAN               
----------------------------------------
 Merge on target t
   ->  Hash Join
         Hash Cond: (s.sid = t.tid)
         ->  Seq Scan on source s
         ->  Hash
               ->  Seq Scan on target t
(6 rows)

EXPLAIN (COSTS OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (4, NULL);
               QUERY PLAN               
----------------------------------------
 Merge on target t
   ->  Hash Left Join
         Hash Cond: (s.sid = t.tid)
         ->  Seq Scan on source s
         ->  Hash
               ->  Seq Scan on target t
(6 rows)

;
DELETE FROM target WHERE tid > 100;
ANALYZE target;
-- insert some matching source rows to work from
INSERT INTO source VALUES (2, 5);
INSERT INTO source VALUES (3, 20);
SELECT * FROM source ORDER BY sid;
 sid | delta 
-----+-------
   2 |     5
   3 |    20
   4 |    40
(3 rows)

SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
(3 rows)

-- equivalent of an UPDATE join
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |       0
   3 |       0
(3 rows)

ROLLBACK;
-- equivalent of a DELETE join
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
(1 row)

ROLLBACK;
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (4, NULL)
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
   4 |        
(4 rows)

ROLLBACK;
-- duplicate source row causes multiple target row update ERROR
INSERT INTO source VALUES (2, 5);
SELECT * FROM source ORDER BY sid;
 sid | delta 
-----+-------
   2 |     5
   2 |     5
   3 |    20
   4 |    40
(4 rows)

SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
(3 rows)

BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
ERROR:  MERGE command cannot affect row a second time
ROLLBACK;
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE
;
ERROR:  MERGE command cannot affect row a second time
ROLLBACK;
-- correct source data
DELETE FROM source WHERE sid = 2;
INSERT INTO source VALUES (2, 5);
SELECT * FROM source ORDER BY sid;
 sid | delta 
-----+-------
   2 |     5
   3 |    20
   4 |    40
(3 rows)

SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
(3 rows)

-- remove constraints
alter table target drop CONSTRAINT target_pkey;
alter table target alter column tid drop not null;
-- multiple actions
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (4, 4)
WHEN MATCHED THEN
	UPDATE SET balance = 0
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |       0
   3 |       0
   4 |       4
(4 rows)

ROLLBACK;
-- should be equivalent
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
WHEN NOT MATCHED THEN
	INSERT VALUES (4, 4);
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |       0
   3 |       0
   4 |       4
(4 rows)

ROLLBACK;
-- column references
-- do a simple equivalent of an UPDATE join
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = t.balance + s.delta
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      25
   3 |      50
(3 rows)

ROLLBACK;
-- do a simple equivalent of an INSERT SELECT
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (s.sid, s.delta)
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
   4 |      40
(4 rows)

ROLLBACK;
-- and again with explicitly identified column list
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta)
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
   4 |      40
(4 rows)

ROLLBACK;
-- and again with a subtle error: referring to non-existent target row for NOT MATCHED
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (t.tid, s.delta)
;
ERROR:  cannot extract attribute from empty tuple slot
-- and again with a constant ON clause
BEGIN;
MERGE INTO target t
USING source AS s
ON (SELECT true)
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (t.tid, s.delta)
;
ERROR:  cannot handle unplanned sub-select
SELECT * FROM target ORDER BY tid;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
-- now the classic UPSERT
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = t.balance + s.delta
WHEN NOT MATCHED THEN
	INSERT VALUES (s.sid, s.delta)
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      25
   3 |      50
   4 |      40
(4 rows)

ROLLBACK;
-- unreachable WHEN clause should ERROR
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN /* Terminal WHEN clause for MATCHED */
	DELETE
WHEN MATCHED AND s.delta > 0 THEN
	UPDATE SET balance = t.balance - s.delta
;
ERROR:  unreachable WHEN clause specified after unconditional WHEN clause
ROLLBACK;
-- conditional WHEN clause
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED AND s.delta > 0 THEN
	UPDATE SET balance = t.balance - s.delta
;
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      15
   3 |      10
(3 rows)

ROLLBACK;
-- test triggers
create or replace function trigfunc () returns trigger
language plpgsql as
$$
BEGIN
	RAISE NOTICE '% % % trigger', TG_WHEN, TG_OP, TG_LEVEL;
	IF (TG_WHEN = 'BEFORE' AND TG_LEVEL = 'ROW') THEN
		IF (TG_OP = 'DELETE') THEN
			RETURN OLD;
		ELSE
			RETURN NEW;
		END IF;
	ELSE
		RETURN NULL;
	END IF;
END;
$$;
CREATE TRIGGER merge_bsi BEFORE INSERT ON target FOR EACH STATEMENT EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_bsu BEFORE UPDATE ON target FOR EACH STATEMENT EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_bsd BEFORE DELETE ON target FOR EACH STATEMENT EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_asi AFTER INSERT ON target FOR EACH STATEMENT EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_asu AFTER UPDATE ON target FOR EACH STATEMENT EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_asd AFTER DELETE ON target FOR EACH STATEMENT EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_bri BEFORE INSERT ON target FOR EACH ROW EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_bru BEFORE UPDATE ON target FOR EACH ROW EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_brd BEFORE DELETE ON target FOR EACH ROW EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_ari AFTER INSERT ON target FOR EACH ROW EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_aru AFTER UPDATE ON target FOR EACH ROW EXECUTE PROCEDURE trigfunc ();
CREATE TRIGGER merge_ard AFTER DELETE ON target FOR EACH ROW EXECUTE PROCEDURE trigfunc ();
-- now the classic UPSERT, with a DELETE
BEGIN;
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED AND t.balance > s.delta THEN
	UPDATE SET balance = t.balance - s.delta
WHEN MATCHED THEN
	DELETE
WHEN NOT MATCHED THEN
	INSERT VALUES (s.sid, s.delta)
;
NOTICE:  BEFORE INSERT STATEMENT trigger
NOTICE:  BEFORE UPDATE STATEMENT trigger
NOTICE:  BEFORE DELETE STATEMENT trigger
NOTICE:  BEFORE INSERT ROW trigger
NOTICE:  BEFORE UPDATE ROW trigger
NOTICE:  BEFORE UPDATE ROW trigger
NOTICE:  AFTER INSERT ROW trigger
NOTICE:  AFTER UPDATE ROW trigger
NOTICE:  AFTER UPDATE ROW trigger
NOTICE:  AFTER DELETE STATEMENT trigger
NOTICE:  AFTER UPDATE STATEMENT trigger
NOTICE:  AFTER INSERT STATEMENT trigger
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      15
   3 |      10
   4 |      40
(4 rows)

ROLLBACK;
-- test from PL/pgSQL
-- make sure MERGE INTO isn't interpreted to mean returning variables like SELECT INTO
BEGIN;
DO LANGUAGE plpgsql $$
BEGIN
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED AND t.balance > s.delta THEN
	UPDATE SET balance = t.balance - s.delta
;
END;
$$;
NOTICE:  BEFORE UPDATE STATEMENT trigger
NOTICE:  BEFORE UPDATE ROW trigger
NOTICE:  BEFORE UPDATE ROW trigger
NOTICE:  AFTER UPDATE ROW trigger
NOTICE:  AFTER UPDATE ROW trigger
NOTICE:  AFTER UPDATE STATEMENT trigger
ROLLBACK;
--source constants
BEGIN;
MERGE INTO target t
USING (SELECT 9 AS sid, 57 AS delta) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta)
;
NOTICE:  BEFORE INSERT STATEMENT trigger
NOTICE:  BEFORE INSERT ROW trigger
NOTICE:  AFTER INSERT ROW trigger
NOTICE:  AFTER INSERT STATEMENT trigger
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
   9 |      57
(4 rows)

ROLLBACK;
--source query
BEGIN;
MERGE INTO target t
USING (SELECT sid, delta FROM source WHERE delta > 0) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta)
;
NOTICE:  BEFORE INSERT STATEMENT trigger
NOTICE:  BEFORE INSERT ROW trigger
NOTICE:  AFTER INSERT ROW trigger
NOTICE:  AFTER INSERT STATEMENT trigger
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
   4 |      40
(4 rows)

ROLLBACK;
BEGIN;
MERGE INTO target t
USING (SELECT sid, delta as newname FROM source WHERE delta > 0) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.newname)
;
NOTICE:  BEFORE INSERT STATEMENT trigger
NOTICE:  BEFORE INSERT ROW trigger
NOTICE:  AFTER INSERT ROW trigger
NOTICE:  AFTER INSERT STATEMENT trigger
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
   4 |      40
(4 rows)

ROLLBACK;
--self-merge
BEGIN;
MERGE INTO target t
USING (SELECT tid as sid, balance as delta FROM target WHERE balance > 0) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta)
;
NOTICE:  BEFORE INSERT STATEMENT trigger
NOTICE:  AFTER INSERT STATEMENT trigger
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
(3 rows)

ROLLBACK;
BEGIN;
MERGE INTO target t
USING
(SELECT sid, max(delta) AS delta
 FROM source
 GROUP BY sid
 HAVING count(*) = 1
 ORDER BY sid ASC) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta)
;
NOTICE:  BEFORE INSERT STATEMENT trigger
NOTICE:  BEFORE INSERT ROW trigger
NOTICE:  AFTER INSERT ROW trigger
NOTICE:  AFTER INSERT STATEMENT trigger
SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      30
   4 |      40
(4 rows)

ROLLBACK;
-- plpgsql parameters and results
BEGIN;
CREATE FUNCTION merge_func (p_id integer, p_bal integer)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
 result integer;
BEGIN
MERGE INTO target t
USING (SELECT p_id AS sid) AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = t.balance - p_bal
;
IF FOUND THEN
	GET DIAGNOSTICS result := ROW_COUNT;
END IF;
RETURN result;
END;
$$;
SELECT merge_func(3, 4);
NOTICE:  BEFORE UPDATE STATEMENT trigger
NOTICE:  BEFORE UPDATE ROW trigger
NOTICE:  AFTER UPDATE ROW trigger
NOTICE:  AFTER UPDATE STATEMENT trigger
 merge_func 
------------
          1
(1 row)

SELECT * FROM target ORDER BY tid;
 tid | balance 
-----+---------
   1 |      10
   2 |      20
   3 |      26
(3 rows)

ROLLBACK;
-- SERIALIZABLE test
-- handled in isolation tests
-- test triggers
-- TODO
-- prepare
RESET SESSION AUTHORIZATION;
DROP TABLE target;
DROP TABLE target2;
DROP TABLE source;
DROP TABLE source2;
DROP USER merge_privs;
ERROR:  role "merge_privs" cannot be dropped because some objects depend on it
DETAIL:  owner of function trigfunc()
DROP USER merge_no_privs;
