Parsed test spec with 2 sessions

starting permutation: merge1 merge2 c1 select2 c2
step merge1: MERGE INTO upsert t USING (SELECT 1 as key, 'merge1' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge1';
step merge2: MERGE INTO upsert t USING (SELECT 1 as key, 'merge2' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge2'; <waiting ...>
step c1: COMMIT;
step merge2: <... completed>
error in steps c1 merge2: ERROR:  duplicate key value violates unique constraint "upsert_pkey"
step select2: SELECT * FROM upsert;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
step c2: COMMIT;

starting permutation: merge1 merge2 a1 select2 c2
step merge1: MERGE INTO upsert t USING (SELECT 1 as key, 'merge1' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge1';
step merge2: MERGE INTO upsert t USING (SELECT 1 as key, 'merge2' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge2'; <waiting ...>
step a1: ABORT;
step merge2: <... completed>
step select2: SELECT * FROM upsert;
key            val            

1              merge2         
step c2: COMMIT;

starting permutation: merge1 c1 merge2 select2 c2
step merge1: MERGE INTO upsert t USING (SELECT 1 as key, 'merge1' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge1';
step c1: COMMIT;
step merge2: MERGE INTO upsert t USING (SELECT 1 as key, 'merge2' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge2';
step select2: SELECT * FROM upsert;
key            val            

1              merge1 updated by merge2
step c2: COMMIT;

starting permutation: insert1 merge1 merge2 c1 select2 c2
step insert1: INSERT INTO upsert VALUES (1, 'insert1');
step merge1: MERGE INTO upsert t USING (SELECT 1 as key, 'merge1' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge1';
step merge2: MERGE INTO upsert t USING (SELECT 1 as key, 'merge2' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge2'; <waiting ...>
step c1: COMMIT;
step merge2: <... completed>
error in steps c1 merge2: ERROR:  duplicate key value violates unique constraint "upsert_pkey"
step select2: SELECT * FROM upsert;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
step c2: COMMIT;

starting permutation: insert1 merge1 merge2 a1 select2 c2
step insert1: INSERT INTO upsert VALUES (1, 'insert1');
step merge1: MERGE INTO upsert t USING (SELECT 1 as key, 'merge1' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge1';
step merge2: MERGE INTO upsert t USING (SELECT 1 as key, 'merge2' as val) s ON s.key = t.key WHEN NOT MATCHED THEN INSERT VALUES (s.key, s.val) WHEN MATCHED THEN UPDATE set val = t.val || ' updated by merge2'; <waiting ...>
step a1: ABORT;
step merge2: <... completed>
step select2: SELECT * FROM upsert;
key            val            

1              merge2         
step c2: COMMIT;
