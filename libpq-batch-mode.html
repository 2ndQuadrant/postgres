<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Batch mode and query pipelining</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6beta1 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C Library"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="Asynchronous Command Processing"
HREF="libpq-async.html"><LINK
REL="NEXT"
TITLE="Retrieving Query Results Row-By-Row"
HREF="libpq-single-row-mode.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2016-05-24T01:54:59"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6beta1 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Asynchronous Command Processing"
HREF="libpq-async.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 31. <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C Library</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Retrieving Query Results Row-By-Row"
HREF="libpq-single-row-mode.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-BATCH-MODE"
>31.5. Batch mode and query pipelining</A
></H1
><P
>   <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> supports queueing up mulitiple queries into
   a pipeline to be executed as a batch on the server. Batching queries allows
   applications to avoid a client/server round-trip after each query to get
   the results before issuing the next query.
  </P
><P
>   An example of batch use may be found in the source distribution in
   <TT
CLASS="FILENAME"
>src/test/examples/libpqbatch.c</TT
>.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN46560"
>31.5.1. When to use batching</A
></H2
><P
>    Much like asynchronous query mode, there is no performance disadvantage to
    using batching and pipelining. It somewhat increased client application
    complexity and extra caution is required to prevent client/server network
    deadlocks, but can offer considerable performance improvements.
   </P
><P
>    Batching is most useful when the server is distant, i.e. network latency
    ("ping time") is high, and when many small operations are being performed in
    rapid sequence. There is usually less benefit in using batches when each
    query takes many multiples of the client/server round-trip time to execute.
    A 100-statement operation run on a server 300ms round-trip-time away would take
    30 seconds in network latency alone without batching; with batching it may spend
    as little as 0.3s waiting for results from the server.
   </P
><P
>    Use batches when your application does lots of small
    <TT
CLASS="LITERAL"
>INSERT</TT
>, <TT
CLASS="LITERAL"
>UPDATE</TT
> and
    <TT
CLASS="LITERAL"
>DELETE</TT
> operations that can't easily be transformed into
    operations on sets or into a
    <A
HREF="libpq-copy.html"
><TT
CLASS="LITERAL"
>COPY</TT
></A
> operation.
   </P
><P
>    Batching less useful when information from one operation is required by the
    client before it knows enough to send the next operation. The client must
    introduce a synchronisation point and wait for a full client/server
    round-trip to get the results it needs. However, it's often possible to
    adjust the client design to exchange the required information server-side.
    Read-modify-write cycles are especially good candidates; for example:
    </P><PRE
CLASS="PROGRAMLISTING"
>     BEGIN;
     SELECT x FROM mytable WHERE id = 42 FOR UPDATE;
     -- result: x=2
     -- client adds 1 to x:
     UPDATE mytable SET x = 3 WHERE id = 42;
     COMMIT;
    </PRE
><P>
    could be much more efficiently done with:
    </P><PRE
CLASS="PROGRAMLISTING"
>     UPDATE mytable SET x = x + 1;
    </PRE
><P>
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     The batch API was introduced in PostgreSQL 9.6, but clients using it can
     use batches on server versions 8.4 and newer. Batching works on any server
     that supports the v3 extended query protocol.
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-BATCH-USING"
>31.5.2. Using batch mode</A
></H2
><P
>    To issue batches the application must switch
    <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> into batch mode. Enter batch mode with <A
HREF="libpq-batch-mode.html#LIBPQ-PQBEGINBATCHMODE"
><CODE
CLASS="FUNCTION"
>PQbeginBatchMode(conn)</CODE
></A
> or test
    whether batch mode is active with <A
HREF="libpq-batch-mode.html#LIBPQ-PQISINBATCHMODE"
><CODE
CLASS="FUNCTION"
>PQisInBatchMode(conn)</CODE
></A
>. In batch mode only <A
HREF="libpq-async.html"
>asynchronous operations</A
> are permitted, and
    <TT
CLASS="LITERAL"
>COPY</TT
> is not allowed. (The restriction on <TT
CLASS="LITERAL"
>COPY</TT
> is an implementation
    limit; the PostgreSQL protocol and server can support batched <TT
CLASS="LITERAL"
>COPY</TT
>).
   </P
><P
>    The client uses libpq's asynchronous query functions to dispatch work,
    marking the end of each batch with <CODE
CLASS="FUNCTION"
>PQsendEndBatch</CODE
>.
    Concurrently, it uses <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> and
    <CODE
CLASS="FUNCTION"
>PQgetNextQuery</CODE
> to get results. It may eventually exit
    batch mode with <CODE
CLASS="FUNCTION"
>PQendBatchMode</CODE
> once all results are
    processed.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     It is best to use batch mode with <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> in
     <A
HREF="libpq-async.html#LIBPQ-PQSETNONBLOCKING"
>non-blocking mode</A
>. If used in
     blocking mode it is possible for a client/server deadlock to occur. The
     client will block trying to send queries to the server, but the server will
     block trying to send results from queries it's already processed to the
     client. This only occurs when the client sends enough queries to fill its
     output buffer and the server's receive buffer before switching to
     processing input from the server, but it's hard to predict exactly when
     that'll happen so it's best to always use non-blocking mode.
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="LIBPQ-BATCH-SENDING"
>31.5.2.1. Issuing queries</A
></H3
><P
>     After entering batch mode the application dispatches requests
     using normal asynchronous <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> functions like
     <CODE
CLASS="FUNCTION"
>PQsendQueryParams</CODE
>, <CODE
CLASS="FUNCTION"
>PQsendPrepare</CODE
>,
     etc. The asynchronous requests are followed by a <A
HREF="libpq-batch-mode.html#LIBPQ-PQSENDENDBATCH"
><CODE
CLASS="FUNCTION"
>PQsendEndBatch(conn)</CODE
></A
> call to mark
     the end of the batch. The client <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>does not</I
></SPAN
> need to call
     <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> immediately after dispatching each
     operation. <A
HREF="libpq-batch-mode.html#LIBPQ-BATCH-RESULTS"
>Result processing</A
>
     is handled separately.
    </P
><P
>     Batched operations will be executed by the server in the order the client
     sends them. The server will send the results in the order the statements
     executed. The server usually begins executing the batch before all commands
     in the batch are queued and the end of batch command is sent. If any
     statement encounters an error the server aborts the current transaction and
     skips processing the rest of the batch. Query processing resumes after the
     end of the failed batch.
    </P
><P
>     It's fine for one operation to depend on the results of a
     prior one. One query may define a table that the next query in the same
     batch uses; similarly, an application may create a named prepared statement
     then execute it with later statements in the same batch.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="LIBPQ-BATCH-RESULTS"
>31.5.2.2. Processing results</A
></H3
><P
>     The client <A
HREF="libpq-batch-mode.html#LIBPQ-BATCH-INTERLEAVE"
>interleaves result
     processing with sending batch queries</A
>, or for small batches may
     process all results after sending the whole batch.
    </P
><P
>     To get the result of the first batch entry the client must call <A
HREF="libpq-batch-mode.html#LIBPQ-PQGETNEXTQUERY"
><CODE
CLASS="FUNCTION"
>PQgetNextQuery</CODE
></A
>. It must then call
     <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> and handle the results until
     <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> returns null (or would return null if
     called). The result from the next batch entry may then be retrieved using
     <CODE
CLASS="FUNCTION"
>PQgetNextQuery</CODE
> and the cycle repeated.  The
     application handles individual statement results as normal.
    </P
><P
>     <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> behaves the same as for normal asynchronous
     processing except that it may contain the new <TT
CLASS="TYPE"
>PGresult</TT
> types
     <TT
CLASS="LITERAL"
>PGRES_BATCH_END</TT
> and <TT
CLASS="LITERAL"
>PGRES_BATCH_ABORTED</TT
>.
     <TT
CLASS="LITERAL"
>PGRES_BATCH_END</TT
> is reported exactly once for each
     <CODE
CLASS="FUNCTION"
>PQsendEndBatch</CODE
> call at the corresponding point in
     the result stream and at no other time. <TT
CLASS="LITERAL"
>PGRES_BATCH_ABORTED</TT
>
     is emitted during error handling; see <A
HREF="libpq-batch-mode.html#LIBPQ-BATCH-ERRORS"
>     error handling</A
>.
    </P
><P
>     <CODE
CLASS="FUNCTION"
>PQisBusy</CODE
>, <CODE
CLASS="FUNCTION"
>PQconsumeInput</CODE
>, etc
     operate as normal when processing batch results.
    </P
><P
>     <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> does not provide any information to the
     application about the query currently being processed. The application
     must keep track of the order in which it sent queries and the expected
     results. Applications will typically use a state machine or a FIFO queue
     for this.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="LIBPQ-BATCH-ERRORS"
>31.5.2.3. Error handling</A
></H3
><P
>     When a query in a batch causes an <TT
CLASS="LITERAL"
>ERROR</TT
> the server
     skips processing all subsequent messages until the end-of-batch message.
     The open transaction is aborted.
    </P
><P
>     From the client perspective, after the client gets a
     <TT
CLASS="LITERAL"
>PGRES_FATAL_ERROR</TT
> return from
     <CODE
CLASS="FUNCTION"
>PQresultStatus</CODE
> the batch is flagged as aborted.
     <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> will report
     <TT
CLASS="LITERAL"
>PGRES_BATCH_ABORTED</TT
> result for each remaining queued
     operation in an aborted batch. The result for
     <CODE
CLASS="FUNCTION"
>PQsendEndBatch</CODE
> is reported as
     <TT
CLASS="LITERAL"
>PGRES_BATCH_END</TT
> to signal the end of the aborted batch
     and resumption of normal result processing.
    </P
><P
>     The client <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>must</I
></SPAN
> process results with
     <CODE
CLASS="FUNCTION"
>PQgetNextQuery(...)</CODE
> and
     <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> during error recovery.
    </P
><P
>     If the batch used an implicit transaction then operations that have
     already executed are rolled back and operations that were queued for after
     the failed operation are skipped entirely. The same behaviour holds if the
     batch starts and commits a single explicit transaction (i.e. the first
     statement is <TT
CLASS="LITERAL"
>BEGIN</TT
> and the last is
     <TT
CLASS="LITERAL"
>COMMIT</TT
>) except that the session remains in an aborted
     transaction state at the end of the batch. If a batch contains <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>     multiple explicit transactions</I
></SPAN
>, all transactions that committed
     prior to the error remain committed, the currently in-progress transaction
     is aborted and all subsequent operations in the current and all later
     transactions in the same batch are skipped completely.
    </P
><P
>     The client must not assume that work is committed when it
     <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>sends</I
></SPAN
> a <TT
CLASS="LITERAL"
>COMMIT</TT
>, only when the
     corresponding result is received to confirm the commit is complete.
     Because errors arrive asynchronously the application needs to be able to
     restart from the last <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>received</I
></SPAN
> committed change and
     resend work done after that point if something goes wrong.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="LIBPQ-BATCH-INTERLEAVE"
>31.5.2.4. Interleaving result processing and query dispatch</A
></H3
><P
>     To avoid deadlocks on large batches the client should be structured around
     a nonblocking I/O loop using a function like <CODE
CLASS="FUNCTION"
>select</CODE
>,
     <CODE
CLASS="FUNCTION"
>poll</CODE
>, <CODE
CLASS="FUNCTION"
>epoll</CODE
>,
     <CODE
CLASS="FUNCTION"
>WaitForMultipleObjectEx</CODE
>, etc.
    </P
><P
>     The client application should generally maintain a queue of work still to
     be dispatched and a queue of work that has been dispatched but not yet had
     its results processed. When the socket is writable it should dispatch more
     work. When the socket is readable it should read results and process them,
     matching them up to the next entry in its expected results queue. Batches
     should be scoped to logical units of work, usually (but not always) one
     transaction per batch. There's no need to exit batch mode and re-enter it
     between batches or to wait for one batch to finish before sending the next.
    </P
><P
>     An example using <CODE
CLASS="FUNCTION"
>select()</CODE
> and a simple state machine
     to track sent and received work is in
     <TT
CLASS="FILENAME"
>src/test/examples/testlibpqbatch.c</TT
> in the PostgreSQL
     source distribution.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="LIBPQ-BATCH-END"
>31.5.2.5. Ending batch mode</A
></H3
><P
>     Once all dispatched commands have had their results processed and the end batch
     result has been consumed the application may return to non-batched mode with
     <A
HREF="libpq-batch-mode.html#LIBPQ-PQENDBATCHMODE"
><CODE
CLASS="FUNCTION"
>PQendBatchMode(conn)</CODE
></A
>.
    </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-FUNCS-BATCH"
>31.5.3. Functions associated with batch mode</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQISINBATCHMODE"
></A
><CODE
CLASS="FUNCTION"
>PQisInBatchMode</CODE
>
      </DT
><DD
><P
>       Returns 1 if a <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> connection is in <A
HREF="libpq-batch-mode.html"
>batch mode</A
>, otherwise 0.

</P><PRE
CLASS="SYNOPSIS"
>int PQisInBatchMode(PGconn *conn);</PRE
><P>

      </P
></DD
><DT
><A
NAME="LIBPQ-PQBEGINBATCHMODE"
></A
><CODE
CLASS="FUNCTION"
>PQbeginBatchMode</CODE
>
      </DT
><DD
><P
>      Causes a connection to enter batch mode if it is currently idle or
      already in batch mode and returns 1 for success. Returns 0 and has no
      effect if the connection is not currently idle, i.e. it has a result
      ready, is waiting for more input from the server, etc. This function
      does not actually send anything to the server, it just changes the
      <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> connection state.

</P><PRE
CLASS="SYNOPSIS"
>int PQbeginBatchMode(PGconn *conn);</PRE
><P>

      </P
></DD
><DT
><A
NAME="LIBPQ-PQENDBATCHMODE"
></A
><CODE
CLASS="FUNCTION"
>PQendBatchMode</CODE
>
      </DT
><DD
><P
>      Causes a connection to exit batch mode if it is currently in batch mode
      with an empty queue and no pending results and returns 1 for success.
      Returns 1 and takes no action if not in batch mode. If the connection has
      pending batch items in the queue for reading with
      <CODE
CLASS="FUNCTION"
>PQgetNextQuery</CODE
>, the current statement isn't finished
      processing or there are results pending for collection with
      <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>, returns 0 and does nothing.

</P><PRE
CLASS="SYNOPSIS"
>int PQendBatchMode(PGconn *conn);</PRE
><P>

      </P
></DD
><DT
><A
NAME="LIBPQ-PQSENDENDBATCH"
></A
><CODE
CLASS="FUNCTION"
>PQsendEndBatch</CODE
>
      </DT
><DD
><P
>      Delimits the end of a set of a batched commands by sending a <A
HREF="protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY"
>sync message</A
> and flushing
      the send buffer. The end of a batch serves as 
      the delimiter of an implicit transaction and
      an error recovery point; see <A
HREF="libpq-batch-mode.html#LIBPQ-BATCH-ERRORS"
>      error handling</A
>.

</P><PRE
CLASS="SYNOPSIS"
>int PQsendEndBatch(PGconn *conn);</PRE
><P>

      </P
></DD
><DT
><A
NAME="LIBPQ-PQGETNEXTQUERY"
></A
><CODE
CLASS="FUNCTION"
>PQgetNextQuery</CODE
>
      </DT
><DD
><P
>      Causes the connection to start processing the next queued query's
      results. Returns 1 if a new query was popped from the result queue
      for processing. Returns 0 and has no effect if there are no query results
      pending, batch mode is not enabled, or if the query currently processed
      is incomplete or still has pending results. See <A
HREF="libpq-batch-mode.html#LIBPQ-BATCH-RESULTS"
>processing results</A
>.

</P><PRE
CLASS="SYNOPSIS"
>int PQgetNextQuery(PGconn *conn);</PRE
><P>

      </P
></DD
><DT
><A
NAME="LIBPQ-PQQUERIESINBATCH"
></A
><CODE
CLASS="FUNCTION"
>PQqueriesInBatch</CODE
>
      </DT
><DD
><P
>      Returns the number of queries still in the queue for this batch, not
      including any query that's currently having results being processsed.
      This is the number of times <CODE
CLASS="FUNCTION"
>PQgetNextQuery</CODE
> has to be
      called before the query queue is empty again.

</P><PRE
CLASS="SYNOPSIS"
>int PQqueriesInBatch(PGconn *conn);</PRE
><P>

      </P
></DD
><DT
><A
NAME="LIBPQ-PQBATCHISABORTED"
></A
><CODE
CLASS="FUNCTION"
>PQbatchIsAborted</CODE
>
      </DT
><DD
><P
>       Returns 1 if the batch curently being received on a
       <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> connection in <A
HREF="libpq-batch-mode.html"
>batch mode</A
> is
       <A
HREF="libpq-batch-mode.html#LIBPQ-BATCH-ERRORS"
>aborted</A
>, 0
       otherwise. The aborted flag is cleared as soon as the result of the
       <CODE
CLASS="FUNCTION"
>PQsendEndBatch</CODE
> at the end of the aborted batch is
       processed. Clients don't usually need this function as they can tell
       that the batch is aborted from <TT
CLASS="LITERAL"
>PGRES_BATCH_ABORTED</TT
>
       result codes.

</P><PRE
CLASS="SYNOPSIS"
>int PQbatchIsAborted(PGconn *conn);</PRE
><P>

      </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-async.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-single-row-mode.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Asynchronous Command Processing</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Retrieving Query Results Row-By-Row</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>